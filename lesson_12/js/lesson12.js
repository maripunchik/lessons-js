// cуворий режим
"use strict";

// ==================== Задачі з одновимірними масивами ===============

// let arr = [56, -78, 252, 23, -122, 356, 122, 436, -111, 344, 21, 3, -356, 342];

// Список індексів елементів, які більші за 100
// ------ варіант 1
// const indArr = []
// arr.forEach((el,ind) =>{
// 	if(el > 100) indArr.push(ind)
// })
// document.writeln(indArr)
// ------ варіант 2
// const indArr = arr.reduce((prevIndArr, el, ind) => {
// 	if(el>100) prevIndArr.push(ind)
// 		return prevIndArr
// }, []) // початковее значення в нас масив [](порожній масив)
// document.writeln(indArr);

// =======================================================

// Список тих цін, які більші за попереднє значення
//                            0                       -1
// let resArr = arr.filter((el, ind, arr) => el > arr[ind - 1]); // в цьому випадку іде звернення до елемента arr[ind - 1] якого не існує, тому потрібно завжди перевіряти (ind > 0):
// let resArr = arr.filter((el, ind, arr) => ind > 0 && el > arr[ind - 1]);

// =======================================================

// Дано історію цін на цінні папери за деякий період (згенерувати від 1 до 10000).
// Сформувати новий масив, що міститиме значення цін у відсотках стосовно максимального
// ----- 1) Коли просять зробити масив із значеннями - то потрібно формувати тільки значення. Не потрібно перетворювати його одразу в string. Якщо його потрібно буде знову використати - в цьому випадку будуть проблеми
// arr.map((el) => ((el / maxValue) * 100)(.toFixed(2) + "%")X);
// ----- 2) відбувається 2 операції:
// const maxValue = Math.max(...arr)
// //                                  1         2
// const arr2 = arr.map((el) => ((el / maxValue) * 100));
// потрібно окремо спочатку вивести коефіцієнт ml= 100/maxValue, щоб потім мати тільки 1 операцію:el* ml
// const maxValue = Math.max(...arr);
// const ml = 100/maxValue // ml (multiplier-множник)
// const arr2 = arr.map((el) => el* ml);

// =======================================================

// Дано історію цін на цінні папери за деякий період (згенерувати від 1 до 10000). Підрахувати кількість змін цін
// const getChangePriceCount = (arr) => {
// 	return arr.reduce((accum, el, index, arr)=>{
// 		if(index > 0 && el !== arr[index-1]) accum++
// 		return accum
// 	}, 0)
// }

// const getChangePriceCount = (arr) => {
//   return arr.reduce((accum, el, index, arr) => {
//     return index > 0 && el !== arr[index - 1] ? accum + 1 : accum; //зменшуємо кількість операцій
//   }, 0);
// };

// ========================================================
// =========== ДВОВИМІРНІ МАСИВИ ============================
// ========================================================

// let arr = [
//   [1, 3, 0, 8, 2],
//   [1, 0, 0, 18, 2],
//   [0, 3, 0, 1, 0],
// ];
// Знайти суму елементів у вказаній області: у парних рядках – непарні стовпці, у непарних – парні.
// let sum = 0;
// ----- 1
// for (let rowIndex = 0; rowIndex < arr.length; rowIndex++) {
//   if (rowIndex % 2 === 0) {
//     for (let colIndex = 1; colIndex < arr[rowIndex].length; colIndex+=2) {
//       sum += arr[rowIndex][colIndex];
//     }
//   } else
//     for (let colIndex = 0; colIndex < arr[rowIndex].length; colIndex+=2) {
//     sum += arr[rowIndex][colIndex];
//     }
// }
// ----- 2
// --- щоб не робити 2 цикли, потрібно скоротити:
// for (let rowIndex = 0; rowIndex < arr.length; rowIndex++) {
//  let startColIndex = rowIndex % 2 === 0 ? 1 : 0
//     for (let colIndex = startColIndex; colIndex < arr[rowIndex].length; colIndex += 2) {
//       sum += arr[rowIndex][colIndex];
//     }
// }
// ----- 3
// for (let rowIndex = 0; rowIndex < arr.length; rowIndex++) {
//     for (let colIndex = 1- rowIndex % 2; colIndex < arr[rowIndex].length; colIndex += 2) {
//       //1- rowIndex % 2(якщо rowIndex % 2 - парне -0 (тоді 1-0=1), якщо непарне- 1(тоді 1-1=0))
//       sum += arr[rowIndex][colIndex];
//     }
// }
// document.writeln(sum)
// ======================================================================

// Знайти загальну кількість нулів у двовимірному масиві
// -----1
// const zeroNum = arr
//   .flat(Infinity) // створення масиву ускладнює задачу, для великих масивів не бажано так робити
//   .reduce((prevZeroNum, el) => (el === 0 ? prevZeroNum + 1 : prevZeroNum), 0);
// ---- 2 краще просто переглянути елементи, і знайти їх:(за допомогою for-of-найшвидший варіант)
// let zeroNum = 0;
// for (const row of arr) {
//   for (const el of row) {
//     if (el === 0) zeroNum++;
//   }
// }
// ----- за допомогою reduce
// const zeroNum = arr.reduce(
//   (prevZeroNum, row) =>
//     prevZeroNum +
//     row.reduce((prevZRow, el) => (el === 0 ? prevZRow + 1 : prevZRow), 0),
//   0
// );
// ======================================================================

// Знайти максимальну кількість нулів у кожному рядочку
// const zeroNumArr = arr.map((row) =>
//   row.reduce((prevZeroRow, el) => (el === 0 ? prevZeroRow + 1 : prevZeroRow), 0)
// );
// document.writeln(zeroNumArr)

// ======================================================================

// Відсортувати тижні (рядки) за спаданням максимального елементи у цьому тижні (рядку), тобто при порівнянні рядків потрібно порівнювати максимальні елементи у кожному з цих рядків
//--- 1 (ДУЖЕ ПОГАНО !!!!!  Дуже багато операцій, один і той самий автобус порівнються багато разів)
// arr.sort((row1, row2) => Math.max(...row2) - Math.max(...row1))
// console.log(arr)
// ---- 2 -значно економимо ресурси, не потрібно кожен раз шукати масимальне
// arr.forEach((row)=>row.push(Math.max(...row))) // додали вкінець кожного рядочка максимальне значення
// arr.sort((row1,row2)=>row2.at(-1)-row1.at(-1))
// arr.forEach((row)=>row.pop()) // після порівняння видаляємо останнє значення
// console.log(arr);

// ======================================================================

// ============= МЕТОДИ SORT ПОТРІБНО ВИКОРИСТОВУВАТИ ТІЛЬКИ КОЛИ В ЦЬОМУ Є ПОТРЕБА!!!!! =========
// ======================================================================
// ================ СОРТУВАННЯ МАСИВІВ ================================
// ======================================================================
// ======================================================================
// ================ СОРТУВАННЯ БУЛЬБАШКОЮ ================================
// ======================================================================

// const arr = [2, 11, 45, 2, 67, 3, 23, 90];

// let change,endIndex = arr.length // описуємо змінні ДО циклу do-while, інакше змінна в циклі потім буде невидима
// do {
//   change = false;
//   for (let i = 1; i < endIndex; i++) {
//     //ОБОВ'ЯЗКОВО i = 1, тому що кожного разу розглядається попереднє (щоб не було помилки)
//     if (arr[i - 1] > arr[i]) { // кожного разу порівнюються 2 сусідні елементи
//       const tmp = arr[i - 1];
//       arr[i - 1] = arr[i];
//       arr[i] = tmp;
//       change = true;
//     }
//   }
//   endIndex-- // останній елемент вже розглядати не будемо, таким чином на кожному кроці кількість елементів які розглядаються будемо зменшувати
// } while (change);
// document.writeln(arr);

// ======================================================================
// ==== СОРТУВАННЯ ЗМІШУВАННЯМ (англ.Coctail sort(shaker)) різновид алгоритму СОРТУВАННЯ БУЛЬБАШКОЮ =====================
// ======================================================================
// let leftIndex = 0;
// let rightIndex = arr.length - 1;
// while (leftIndex < rightIndex) {
//   //--- проходимось зліва-направо
//   let changed = false;
//   for (let i = leftIndex + 1; i <= rightIndex; i++) {
//     if (arr[i - 1] > arr[i]) {
//       let temp = arr[i - 1];
//       arr[i - 1] = arr[i];
//       arr[i] = temp;
//       changed = true;
//     }
//   }
//   rightIndex--;
//   if (changed === false) break;
//   //---- проходимось справа-наліво
//   changed = false;
//   for (let i = rightIndex; i > leftIndex; i--) {
//     if (arr[i - 1] > arr[i]) {
//       let temp = arr[i - 1];
//       arr[i - 1] = arr[i];
//       arr[i] = temp;
//       changed = true;
//     }
//   }
//   leftIndex++;
//   if (changed === false) break;
// }
// document.writeln(arr);
// ======================================================================
// ================ СОРТУВАННЯ ВИБОРОМ 1 ================================
// ======================================================================

// const prevLastIndex = arr.length - 2; // до передостаннього елемента
// for (let i = 0; i < prevLastIndex; i++) {  // для кожної позиції "i"-треба поставити мінімальний(від i+1 до останнього)
//   for (let j = i+1; j < array.length; j++) {
//     // розглядаємо елем.від наступного(i+1) до останнього
//     if (arr[i] < arr[j]) { // якщо елемент у позиції j є меншим-то міняємо з i-товим
//       let temp = arr[i];
//       arr[i] = arr[j];
//       arr[j] = temp;
//     }
//   }
// }
// document.writeln(arr);

// ======================================================================
// ================ СОРТУВАННЯ ВИБОРОМ 2 ================================
// ======================================================================

// const prevLastIndex = arr.length - 2; // до передостаннього елемента
// let counter = 0
// for (let i = 0; i <= prevLastIndex; i++) {
//   let minIndex = i; //  minIndex -корзинка з індексами баби Галі
//   //----- пошук індекса мінімального елемента від і-до останнього
//   for (let j = i + 1; j < arr.length; j++) {
//     if (arr[j] < arr[minIndex]) {
//       minIndex = j;
//     }
//   }
//   //---- якщо мінімальний не у позиції "і" то міняємо місцями
//   if (i !== minIndex) {
//     let temp = arr[i];
//     arr[i] = arr[minIndex];
//     arr[minIndex] = temp;
// 	 counter++
//   }
// }
// document.writeln(arr);
// console.log(counter);

// ======================================================================
// ===================== СОРТУВАННЯ ВКЛЮЧЕННЯМ(вставками) =============
// (справа наліво  порівнюємо елемент і вставляємо на потрібне місце. Ніби, учнів просимо посунитись кожен раз вправо, щоб зліва поставити в правильну позицію ================
// На кожному кроці
// вставляємо i-вий елемент у правильну позицію зліва;
// при цьому вважаємо, що всі елементи, що розташовані лівіше, упорядковані за зростанням

// function insertSort(arr) {
// 	for (let k = 1; k < arr.length; k++) {
// 		key=arr[k]
//     const currentElement = arr[k];
//     let i = k - 1; // починаємо порівнювати з попеереднього k-1
//     while (i >= 0 && arr[i] > currentElement) {
//       //якщо arr[i] - попередній елемент, є більшим, його посуваємо вправо, а на його місце ставимо  key(/currentElement) - поточний елемент
//       arr[i + 1] = arr[i]; // arr[i+1] - посунутий елемент
//       i = i - 1;
//     }
//     arr[i + 1] = currentElement;
//   }
// }

// function insertSort(arr) {
// 	let key,i
//   for (let k = 1; k < arr.length; k++) {
//     key = arr[k];
//     i = k - 1; // починаємо порівнювати з попереднього k-1
//     while (i >= 0 && arr[i] > key) {
//       //якщо arr[i] - попередній елемент, є більшим, його посуваємо вправо, а на його місце ставимо  key(/currentElement) - поточний елемент
//       arr[i + 1] = arr[i]; // arr[i+1] - посунутий елемент
//       i = i - 1;
//     }
//     arr[i + 1] = key;
//   }
// }
// ======================================================================
// ---------------------------------------------------------------------

// ================== ЛІНІЙНИЙ ПОШУК елемента у масиві ======================================
// function indexOf(arr, el) {
// 	let elIndex = -1 // неіснуючий індекс (бо індекси починаються з 0)
// 	for (let i = 0; i < arr.length; i++) {
// 	if(arr[i] === el) {
// 		elIndex = i
// 		break
// 	}
// 	}
// 	return elIndex
// }

// Двійковий(бінарний) пошук (замість того, щоб вікривати кожну комірку, обчислюється middle, що знаходиться між start та end)
// числа у скринях упорядковані за зростанням зліва направо
// ---- перевірка належності упорядкованого масиву
// ---- (належить-true, не належить-false)
// function includers_binarySearch(a,searchElement) {
//   let start = 0; // початковий номер діапазону пошуку
//   let end = a.length - 1; // кінцевий номер діапазону пошуку
// while (start<=end) {
// 	const middle =Math.floor((start+end)/2)
// if(a[middle]===searchElement)return true
// if (a[middle] < searchElement) start = middle+1;
// if (a[middle] > searchElement) end = middle-1;
// }
//   return false;
// }
// const sortedArray = insertSort(a)
// document.writeln(a)
// if(includers_binarySearch(a,4))alert(`4 входить у масив`)
// 	else alert(`4 не входить у масив`);
